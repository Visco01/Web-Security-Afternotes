#+title: Web Security

* Web Sessions Security

** Session Management
1) *Server-side state*: Persist the state information on the server, e.g., in a
   database, and use the cookie just to store a session identifier. The database
   storing session information can become a bottleneck.
2) *Client-side state*: Persist the state information directly into the cookie.
   A secure implementation requires the use of cryptography, at least for
   signing the cookie and possibly for encrypting it.

** Attacks on sessions integrity

*** Session hijacking
An attacker who gets access to a honest user’s cookies can impersonate her by
presenting such cookies: this attack is known as session hijacking.

#+begin_quote
*HTTP only cookie*: Cookies marked with the HttpOnly attribute are not
 accessible to JS, thus offering confidentiality against web attackers.
#+end_quote

#+begin_quote
*Secure cookies*: Cookies marked with the Secure attribute are only sent over
 HTTPS and made inaccessible to JavaScript running in HTTP pages. The Secure
 attribute should be used even when the web application is entirely deployed
 over HTTPS.
#+end_quote

*** Session fixation
Many web applications use *pre-sessions* (unauthenticated sessions) to keep
track of state information even before login. For example, Most e-commerce
applications allow users to add items to their shopping cart before login for
usability reasons. The content of the cart is persisted upon login to enable
payments. *Cookies storing session identifiers should be refreshed every time
the privilege level of the session changes, e.g., upon login*. Otherwise, the
web application might be vulnerable to *session fixation*.

#+begin_quote
*Session fixation through cookie*: This method explores the server response to
 fix the Session ID in the victim’s browser. Including the parameter Set-Cookie
 in the HTTP header response, the attacker is able to insert the value of
 Session ID in the cookie and sends it to the victim’s browser.
#+end_quote

**** Preventing Session fixation
1) *Refresh cookies upon authentication*: when the credentials are verified,
   change the value of the cookie and start a new session;
2) *Enforce cookie integrity*: ensure that the attacker cannot set cookies for
   the target web application

*** Cross-Site-Request-Forgery
Since cookies are automatically attached to HTTP requests by default, an
attacker can *force the creation of authenticated requests from the victim’s
browser*, which might trigger security-sensitive actions (CSRF).

Discussed below in detail.

*** Cookie forcing
Cookie forcing is not necessarily dangerous, but can be nasty. *Example*: Since
paypal.com binds a credit card number to a personal account, an attacker can
perform cookie forcing on paypal.com to eventually *get access to the credit
card* number of the victim.

** Session expiration
Cookies are deleted by default when the web browser is closed, but web
applications can modify this through the *Expires* attribute:
- *long session lifetimes* improve usability, but might harm security;
- make the *“Remember Me”* functionality an opt-in.

*Implementation*:
- *Server-Side State*: Expiration is simple to implement: just invalidate the
  session identifier by deleting the corresponding entries from the database.
- *Client-Side State*: Include an expiration date as part of the encrypted data
  and implement a blacklist of session cookies issued to compromised accounts.

* Same Origin Policy (SOP)
The Same Origin Policy (SOP) is the baseline defense mechanism of web browsers,
which isolates data controlled by good.com from read / write accesses by scripts
served from evil.com.

** Web Origins
SOP defines its own isolation domains in terms of origins.

#+begin_quote
*Origin*: An origin is a triple including a scheme, a hostname and a port. When
 the port is omitted, the default port of the scheme is implicitly assumed.
#+end_quote

#+begin_quote
*SOP restrictions*: At a high level, SOP can be summarized as follows: data
 owned by origin $o_{1}$ must be isolated from read / write accesses by any
 origin $o_{2} \neq o_{1}$.
#+end_quote

** Cookies VS Web Storage

| Cookies                          | Web Storage                        |
| - Relaxed SOP (insicure)         | + Traditional SOP (more secure)    |
| - Sent automatically (CSRF)      | + Sent on demand (no CSRF)         |
| + HttpOnly: shielded from JS     | - Always accessible to JS (risky)  |
| + Sessions are easy to implement | - Sessions require custom JS logic |

*Cookies + Web Storage = Better sessions* against the Session hijacking, session
fixation, CSRF.

** SOP and content inclusion
Since the Web is designed to be interconnected, *SOP puts very little
restrictions* on content inclusion. For example, foo.com can normally load
images and stylesheets from bar.com.

#+begin_quote
*Sub-Resource Integrity*: It is possible to enforce integrity checks on included
 scripts, browsers fetching the remote script compare the hash in the integrity
 tag with the hash computed from the downloaded script; if the two hashes do not
 match, the script is not loaded. *Difficult to deploy*.
#+end_quote

** Cross-Origin-Resource-Sharing (CORS)
CORS provides a disciplined way to relax the restrictions of SOP:
1) foo.com asks for permission to read cross-origin data;
2) bar.com grants or denies such permission;
3) the browser enforces the authorization decision at foo.com;

#+begin_quote
*CORS headers*:
- *Origin*: request header containing the origin which is asking for
  cross-origin read permission;
- *Access-Control-Allow-Origin*: response header containing the origin to which
  such permission is granted (* for any origin).

  Access is granted iff the content of the Access-Control-Allow-Origin header
  matches the content of the Origin header.
#+end_quote

*** CORS: Non-Simple Requests
#+begin_quote
*CORS headers*:
- *Access-Control-Request-Method*: preflight request header containing the
  method of the non-simple request;
- *Access-Control-Request-Headers*: preflight request header containing the list
  of the custom headers of the non-simple request;
- *Access-Control-Allow-Methods*: preflight response header containing a list of
  allowed methods;
- *Access-Control-Allow-Headers*: preflight response header containing a list of
  allowed custom headers;
- *Access-Control-Max-Age*: preflight response header for caching.
#+end_quote

*** Security of CORS
CORS is a standardized, more secure alternative to JSONP:
1) *No script injection*: though the callee can still respond with arbitrary
   content, the caller can process the response (not a script) before actually
   using it. This is normally done in the XHR callback.
2) *No information leakage*: only credentialed requests might disclose
   confidential information and the callee has control over them, thanks to the
   Access-Control-Allow-Origin header.

* Cross-site scripting (XSS)
Cross Site Scripting (XSS) is the king of client-side attacks, because it allows
the attacker to inject scripts on a vulnerable web application: when a malicious
script runs in the target’s origin, *SOP is ineffective*.

*XSS flow*:
1) the attacker identifies a part of the target web application which processes
   *untrusted input from the user*, e.g., a search field;
2) the attacker discovers that the supplied *input can be eventually interpreted
   as a script*, e.g., using their own browser;
3) the attacker sends a maliciously crafted link to the victim, who accesses it
   and triggers a script injection;
4) since the script actually comes from the target web application, it runs *in
   the same origin of the target*.

** XSS Categories
#+begin_quote
*Type flow*:
- *Reflected XSS*: happens when web applications echo back untrusted user input
  to the client.
- *Persistent XSS*: happens when web applications store untrusted user input
  somewhere and automatically echo it back later.
#+end_quote

#+begin_quote
*Location of flow*:
- *Server-side XSS*: vulnerable code on the server (“traditional” XSS)
- *Client-side XSS*: vulnerable code on the client (DOM-based XSS)
#+end_quote

*** Categories summary
| *Reflected server-side XSS*                               | *Reflected client-side XSS*                               | *Persistent server-side XSS*                   | *Persistent client-side* XSS                    |
| User must visit malicious link                            | User must visit malicious link                            | Attacker can store malicious payload on server | User must visit malicious link, but just once   |
| No persistent change to the server (one attack per visit) | No persistent change to the client (one attack per visit) | Every user of the site affected on every visit | Single user of the site affected on every visit |

*** XSS Polyglot
A polyglot is an exploit working in several different contexts:
#+begin_src javascript
javascript:alert()//"){}alert();//</a><script>alert()</script>
#+end_src

** XSS defenses
| *Output encoding*                                   | *Input Sanitization*                                    |
| Very easy to use                                    | Don’t do it by yourself!                                |
| Solves the root cause of the security vulnerability | Some attacks like markup injection might still be there |
| Sometimes restrictive                               | Sometimes necessary                                     |

* Content Security Policy (CSP)
CSP was born as an industrial effort to design a *declarative client-side defense*
mechanism *against XSS* in 2010:
- Now supported by all major web browsers;
- Useful defense-in-depth (*mitigation*) approach against XSS: it does not
  substitute input sanitization and output encoding;
- No protection against scriptless attacks like HTML markup injection.

A CSP is a *page-level security policy* delivered to the browser via the
*Content-Security-Policy* header. The browser then takes care of enforcing the
policy on the page.

** CSP directives
| *Directive* | *Applies to*                |
| connect-src | Targets of XHRs             |
| img-src     | Images and favicons         |
| object-src  | Plugins (Flash, applets...) |
| script-src  | JavaScript files            |
| style-src   | CSS files                   |
| default-src | Fallback directive          |

** CSP default restrictions (script-src, default-src)
*Script execution*:
- No execution of inline scripts;
- No execution of inline event handlers, e.g., onerror;
- No execution of javascript: URLs.

*String-to-code transformation*:
- Invocation of the eval function is forbidden;
- Functions like setTimeout must be invoked with a callable.

** CSP Roadblocks
1) *Whitelist*: The simplest way to build whitelists is to enforce a restrictive
   CSP as report-only via the *Content-Security-Policy-Report-Only* header;
2) *Inline Scripts and Friends*: CSP forbids inline scripts, event handlers and javascript, so one has to:
   1) Move inline scripts to external files;
   2) Replace event handlers with listeners registered by external scripts;
   3) Replace javascript: URLs with script-initiated code.
3) *String-to-Code Transformations*: Functions like eval and setTimeout can be used to transform strings into code, thus leading to injections.

** CSP Nonces
CSP can now be used to whitelist scripts (inline or external) bearing a *valid
nonce*, i.e., a random, unpredictable string:
#+begin_src html
script-src  ’self’ https://example.com ’nonce-54321’;
default-src ’self’
#+end_src

Individual inline scripts can be whitelisted using the nonce attribute (the same nonce can be used for many inline scripts):
#+begin_src html
<script nonce="54321"> alert(1); </script>
#+end_src

*Nonces advantages*:
- They provide support for inline scripts, without falling back to the complete
  absence of security of ’unsafe-inline’;
- They whitelist individual scripts as opposed to entire origins, which
  simplifies the security auditing

#+begin_quote
The developer is in charge of generating random, unpredictable nonces on each
incoming request and populating the CSP header correctly: *Nonce reuse can
easily break protection against XSS*.
#+end_quote

** Supporting dynamic scripts
Make use of the *’strict-dynamic’* keyword, which propagates trust from
nonce-authorized scripts to the new scripts they insert.

Or, *CSP hashes*: Hashes provide better security guarantees than nonces, because
they take the actual script code into account.
#+begin_src html
script-src ’sha512-YWIzOWNiNzJjNDRlY’;
#+end_src
The following inline script will be executed, under the assumption that the SHA-512 hash of its body is YWIzOWNiNzJjNDRlY:
#+begin_src html
<script> alert(1); </script>
#+end_src

#+begin_quote
*’strict-dynamic’ also covers hash-authorized scripts*.
#+end_quote

** Summary: How to configure CSP?
1) *whitelist-based*: often *insecure*. Even assuming CSP best practices are followed, it is basically impossible to
   vet entire origins;
2) *nonce-based*: *more secure, but no guarantees* about the executed script content. Be aware of the dangers of ’strict-dynamic’;
3) *hash-based*: *complete control* of the executed scripts, including their content, but often *too complicated to deploy* in practice.
